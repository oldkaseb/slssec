# -*- coding: utf-8 -*-
# Souls Guard Bot ‚Äî single file (FULL, text-only commands)
# Python 3.11+
import asyncio
import logging
import os
import re
from datetime import datetime, timedelta, date
from zoneinfo import ZoneInfo

import asyncpg
from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode, ChatType
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart
from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove, ChatMemberUpdated
from aiogram.utils.keyboard import InlineKeyboardBuilder
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

APP_VERSION = "2025-08-31-text"
STARTED_AT = datetime.utcnow()

# -------- Optional Telethon (userbot) ----------
ENABLE_TELETHON = os.getenv("ENABLE_TELETHON", "0") == "1"
if ENABLE_TELETHON:
    from telethon import TelegramClient, events
    from telethon.sessions import StringSession
    TELETHON_SESSION = os.getenv("TELETHON_SESSION", "")
    API_ID = int(os.getenv("API_ID", "0") or "0")
    API_HASH = os.getenv("API_HASH", "")

# --------------------------- ENV & GLOBALS ---------------------------
BOT_TOKEN = os.environ["BOT_TOKEN"]
DATABASE_URL = os.environ["DATABASE_URL"]
OWNER_ID = int(os.environ["OWNER_ID"])
MAIN_CHAT_ID = int(os.environ["MAIN_CHAT_ID"])
GUARD_CHAT_ID = int(os.environ["GUARD_CHAT_ID"])
TEHRAN = ZoneInfo(os.getenv("TZ", "Asia/Tehran"))

ROLES = {
    "owner",
    "senior_chat", "senior_call", "senior_all",
    "admin_chat", "admin_call", "admin_channel",
    "member"
}

ROLE_ORDER = {
    "owner": 0,
    "senior_all": 1,
    "senior_chat": 2,
    "senior_call": 3,
    "admin_channel": 4,
    "admin_chat": 5,
    "admin_call": 6,
    "member": 99
}

# ŸÖÿ¨Ÿàÿ≤ ŸÜŸÇÿ¥‚ÄåŸáÿß
ALLOWED_VOICE_ROLES = {
    "owner", "senior_all", "senior_call", "admin_call",
    "senior_chat", "admin_chat",
}
ALLOWED_CHAT_ROLES = {
    "owner", "senior_all", "senior_chat", "admin_chat"
}

# Ÿàÿ∂ÿπ€åÿ™‚ÄåŸáÿß€å ŸÖŸàŸÇÿ™
PENDING_REPORT = {}
PENDING_CONTACT_OWNER = set()
PENDING_CONTACT_GUARD = set()
CALL_HEARTBEATS = {}  # {user_id: datetime}

# ------------------------------ Logging --------------------------------------
logging.basicConfig(level=logging.INFO)
log = logging.getLogger("souls-bot")

# ----------------------------- Utilities -------------------------------------
def now_teh() -> datetime:
    return datetime.now(tz=TEHRAN)

def today_teh() -> date:
    return now_teh().date()

def is_admin_role(role: str) -> bool:
    return role in {
        "owner", "senior_chat", "senior_call", "senior_all",
        "admin_chat", "admin_call", "admin_channel"
    }

def pretty_td(seconds: int) -> str:
    if seconds < 0: seconds = 0
    h, r = divmod(seconds, 3600)
    m, s = divmod(r, 60)
    return f"{h:02d}:{m:02d}:{s:02d}"

def role_title(role: str) -> str:
    return {
        "owner": "üëë ŸÖÿßŸÑ⁄©",
        "senior_all": "üõ°Ô∏è ÿßÿ±ÿ¥ÿØ ⁄©ŸÑ",
        "senior_chat": "üõ°Ô∏è ÿßÿ±ÿ¥ÿØ ⁄Üÿ™",
        "senior_call": "üõ°Ô∏è ÿßÿ±ÿ¥ÿØ ⁄©ÿßŸÑ",
        "admin_channel": "üì¢ ÿßÿØŸÖ€åŸÜ ⁄©ÿßŸÜÿßŸÑ",
        "admin_chat": "üí¨ ÿßÿØŸÖ€åŸÜ ⁄Üÿ™",
        "admin_call": "üéôÔ∏è ÿßÿØŸÖ€åŸÜ ⁄©ÿßŸÑ",
        "member": "üë§ ÿπÿ∂Ÿà"
    }.get(role, role)

def src_tag(chat_id: int) -> str:
    return f"src:{chat_id}"

def uptime_str() -> str:
    d = datetime.utcnow() - STARTED_AT
    s = int(d.total_seconds())
    return pretty_td(s)

# ----------------------------- Database --------------------------------------
SCHEMA_SQL = """
CREATE TABLE IF NOT EXISTS users(
    user_id BIGINT PRIMARY KEY,
    username TEXT, first_name TEXT, last_name TEXT,
    role TEXT DEFAULT 'member',
    rank INT DEFAULT 0,
    joined_guard_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS groups(
    group_type TEXT PRIMARY KEY, -- 'main' / 'guard'
    chat_id BIGINT,
    title TEXT
);

CREATE TABLE IF NOT EXISTS sessions(
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    kind TEXT CHECK (kind IN ('chat','call')) NOT NULL,
    start_at TIMESTAMPTZ NOT NULL,
    end_at TIMESTAMPTZ,
    last_activity TIMESTAMPTZ,
    start_date DATE NOT NULL,
    source TEXT
);

CREATE UNIQUE INDEX IF NOT EXISTS uniq_open_session
ON sessions (user_id, kind) WHERE end_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_sessions_open ON sessions(user_id, kind) WHERE end_at IS NULL;

CREATE TABLE IF NOT EXISTS chat_metrics(
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    d DATE NOT NULL,
    msgs INT DEFAULT 0,
    replies_sent INT DEFAULT 0,
    replies_received INT DEFAULT 0,
    PRIMARY KEY (user_id, d)
);

CREATE TABLE IF NOT EXISTS feedback(
    id BIGSERIAL PRIMARY KEY,
    target_user_id BIGINT,
    giver_user_id BIGINT,
    d DATE NOT NULL,
    score INT,
    context TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS bans(
    user_id BIGINT PRIMARY KEY,
    reason TEXT,
    banned_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS candidates_daily(
    user_id BIGINT,
    d DATE NOT NULL,
    chat_msgs INT DEFAULT 0,
    call_seconds INT DEFAULT 0,
    presence_seconds INT DEFAULT 0,
    PRIMARY KEY (user_id, d)
);

CREATE TABLE IF NOT EXISTS first_prompt_main(
    user_id BIGINT,
    d DATE NOT NULL,
    PRIMARY KEY (user_id, d)
);

CREATE INDEX IF NOT EXISTS idx_chat_metrics_user_d ON chat_metrics(user_id, d);
CREATE INDEX IF NOT EXISTS idx_sessions_date_kind_user ON sessions(start_date, kind, user_id);
"""

async def ensure_user(pool, u):
    async with pool.acquire() as con:
        await con.execute("""
            INSERT INTO users(user_id, username, first_name, last_name)
            VALUES($1,$2,$3,$4)
            ON CONFLICT (user_id) DO UPDATE SET
                username=EXCLUDED.username,
                first_name=EXCLUDED.first_name,
                last_name=EXCLUDED.last_name,
                updated_at=now()
        """, u.id, (u.username or ""), (u.first_name or ""), (u.last_name or ""))

async def get_role(pool, user_id: int) -> str:
    async with pool.acquire() as con:
        r = await con.fetchval("SELECT role FROM users WHERE user_id=$1", user_id)
        return r or "member"

async def set_role(pool, user_id: int, role: str):
    if role not in ROLES: return False
    async with pool.acquire() as con:
        await con.execute("""
            INSERT INTO users(user_id, role, joined_guard_at)
            VALUES($1,$2,now())
            ON CONFLICT (user_id) DO UPDATE SET role=EXCLUDED.role,
            joined_guard_at = COALESCE(users.joined_guard_at, now())
        """, user_id, role)
    return True

async def open_session(pool, user_id: int, kind: str, source: str=None):
    d = today_teh()
    t = now_teh()
    async with pool.acquire() as con:
        await con.execute("""
            UPDATE sessions SET end_at=now(), last_activity=now()
            WHERE user_id=$1 AND kind=$2 AND end_at IS NULL AND start_date<>$3
        """, user_id, kind, d)
        try:
            await con.execute("""
                INSERT INTO sessions(user_id, kind, start_at, last_activity, start_date, source)
                VALUES($1,$2,$3,$3,$4,$5)
            """, user_id, kind, t, d, source or "")
        except Exception:
            await con.execute("""
                UPDATE sessions SET last_activity=now()
                WHERE user_id=$1 AND kind=$2 AND end_at IS NULL
            """, user_id, kind)

async def touch_activity(pool, user_id: int, kind: str):
    async with pool.acquire() as con:
        await con.execute("""
            UPDATE sessions SET last_activity=now()
            WHERE user_id=$1 AND kind=$2 AND end_at IS NULL
        """, user_id, kind)

async def close_session(pool, user_id: int, kind: str):
    async with pool.acquire() as con:
        await con.execute("""
            UPDATE sessions SET end_at=now(), last_activity=now()
            WHERE user_id=$1 AND kind=$2 AND end_at IS NULL
        """, user_id, kind)

async def count_open(pool, user_id: int, kind: str) -> int:
    async with pool.acquire() as con:
        return await con.fetchval("""
            SELECT count(*) FROM sessions
            WHERE user_id=$1 AND kind=$2 AND end_at IS NULL
        """, user_id, kind)

async def inc_chat_metrics(pool, user_id: int, msg: Message):
    # ŸÅŸÇÿ∑ ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å
    d = today_teh()
    is_reply = msg.reply_to_message is not None
    async with pool.acquire() as con:
        await con.execute("""
            INSERT INTO chat_metrics(user_id, d, msgs, replies_sent, replies_received)
            VALUES($1,$2,$3,$4,$5)
            ON CONFLICT (user_id, d) DO UPDATE SET
                msgs = chat_metrics.msgs + EXCLUDED.msgs,
                replies_sent = chat_metrics.replies_sent + EXCLUDED.replies_sent,
                replies_received = chat_metrics.replies_received + EXCLUDED.replies_received
        """, user_id, d, 1, (1 if is_reply else 0), 0)
        if is_reply and msg.reply_to_message and msg.reply_to_message.from_user:
            target = msg.reply_to_message.from_user.id
            await con.execute("""
                INSERT INTO chat_metrics(user_id, d, msgs, replies_sent, replies_received)
                VALUES($1,$2,0,0,1)
                ON CONFLICT (user_id, d) DO UPDATE SET
                    replies_received = chat_metrics.replies_received + 1
            """, target, d)

        await con.execute("""
            INSERT INTO candidates_daily(user_id, d, chat_msgs)
            VALUES($1,$2,1)
            ON CONFLICT (user_id, d) DO UPDATE SET
                chat_msgs = candidates_daily.chat_msgs + 1
        """, user_id, d)

# ---------- ÿ¢ŸÖÿßÿ± ¬´ŸÅŸÇÿ∑ ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å¬ª ----------
def _main_src_like():
    return f"%{src_tag(MAIN_CHAT_ID)}%"

async def admin_today_stats_main(pool, user_id: int):
    d = today_teh()
    pat = _main_src_like()
    async with pool.acquire() as con:
        row = await con.fetchrow("""
        WITH cm AS (
            SELECT COALESCE(SUM(msgs),0) as msgs,
                   COALESCE(SUM(replies_sent),0) as r_sent,
                   COALESCE(SUM(replies_received),0) as r_recv
            FROM chat_metrics WHERE user_id=$1 AND d=$2
        ),
        chat_secs AS (
            SELECT COALESCE(SUM(EXTRACT(EPOCH FROM (COALESCE(end_at, now()) - start_at)))::INT,0) AS secs
            FROM sessions
            WHERE user_id=$1 AND kind='chat' AND start_date=$2 AND source LIKE $3
        ),
        call_secs AS (
            SELECT COALESCE(SUM(EXTRACT(EPOCH FROM (COALESCE(end_at, now()) - start_at)))::INT,0) AS secs
            FROM sessions
            WHERE user_id=$1 AND kind='call' AND start_date=$2 AND source LIKE $3
        )
        SELECT cm.msgs, cm.r_sent, cm.r_recv, chat_secs.secs as chat_secs, call_secs.secs as call_secs
        FROM cm, chat_secs, call_secs
        """, user_id, d, pat)
        return row

async def admins_overview_today_main(pool):
    d = today_teh()
    pat = _main_src_like()
    async with pool.acquire() as con:
        rows = await con.fetch("""
        WITH u AS (
            SELECT user_id, role, rank, username, first_name, last_name
            FROM users WHERE role <> 'member'
        ),
        chat_secs AS (
            SELECT user_id, COALESCE(SUM(EXTRACT(EPOCH FROM (COALESCE(end_at, now()) - start_at)))::INT,0) as chat_secs
            FROM sessions
            WHERE kind='chat' AND start_date=$1 AND source LIKE $2
            GROUP BY user_id
        ),
        call_secs AS (
            SELECT user_id, COALESCE(SUM(EXTRACT(EPOCH FROM (COALESCE(end_at, now()) - start_at)))::INT,0) as call_secs
            FROM sessions
            WHERE kind='call' AND start_date=$1 AND source LIKE $2
            GROUP BY user_id
        ),
        cm AS (
            SELECT user_id, COALESCE(SUM(msgs),0) as msgs
            FROM chat_metrics WHERE d=$1
            GROUP BY user_id
        )
        SELECT u.*, COALESCE(cm.msgs,0) as msgs,
               COALESCE(chat_secs.chat_secs,0) as chat_secs,
               COALESCE(call_secs.call_secs,0) as call_secs
        FROM u
        LEFT JOIN cm ON cm.user_id=u.user_id
        LEFT JOIN chat_secs ON chat_secs.user_id=u.user_id
        LEFT JOIN call_secs ON call_secs.user_id=u.user_id
        """, d, pat)
        return rows

async def last_30_days_stats_main(pool, user_id: int):
    start_d = today_teh() - timedelta(days=30)
    pat = _main_src_like()
    async with pool.acquire() as con:
        row = await con.fetchrow("""
        WITH cm AS (
            SELECT COALESCE(SUM(msgs),0) msgs,
                   COALESCE(SUM(replies_sent),0) rs,
                   COALESCE(SUM(replies_received),0) rr
            FROM chat_metrics WHERE user_id=$1 AND d >= $2
        ),
        sess AS (
            SELECT kind, COALESCE(SUM(EXTRACT(EPOCH FROM (COALESCE(end_at, now()) - start_at)))::INT,0) secs
            FROM sessions WHERE user_id=$1 AND start_date >= $2 AND source LIKE $3
            GROUP BY kind
        )
        SELECT cm.msgs, cm.rs, cm.rr,
               COALESCE((SELECT secs FROM sess WHERE kind='chat'),0) chat_secs,
               COALESCE((SELECT secs FROM sess WHERE kind='call'),0) call_secs
        """, user_id, start_d, pat)
    return row

# ----------------------------- Keyboards -------------------------------------
def kb_dual(kind_mode: str, user_id: int, show_chat=True, show_call=True):
    b = InlineKeyboardBuilder()
    if show_chat:
        b.button(text=("‚úÖ ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ ⁄Üÿ™" if kind_mode=="ci" else "‚ùå ÿ´ÿ®ÿ™ ÿÆÿ±Ÿàÿ¨ ⁄Üÿ™"), callback_data=f"{kind_mode}:chat:{user_id}")
    if show_call:
        b.button(text=("‚úÖ ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ ⁄©ÿßŸÑ" if kind_mode=="ci" else "‚ùå ÿ´ÿ®ÿ™ ÿÆÿ±Ÿàÿ¨ ⁄©ÿßŸÑ"), callback_data=f"{kind_mode}:call:{user_id}")
    if show_chat and show_call:
        b.adjust(2)
    else:
        b.adjust(1)
    return b.as_markup()

def kb_first_msg_dual_checkin(user_id: int):
    return kb_dual("ci", user_id, True, True)

def kb_feedback(target_user_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="üëç ÿ±ÿßÿ∂€å", callback_data=f"fb:{target_user_id}:1")
    b.button(text="üëé ŸÜÿßÿ±ÿßÿ∂€å", callback_data=f"fb:{target_user_id}:-1")
    b.adjust(2)
    return b.as_markup()

def kb_admin_panel(role: str, is_owner: bool=False):
    b = InlineKeyboardBuilder()
    b.button(text="üìä ÿ¢ŸÖÿßÿ± ŸÖŸÜ", callback_data="pv:me")
    b.button(text="üìà ÿ¢ŸÖÿßÿ± ⁄©ŸÑ€å ŸÖŸÜ", callback_data="pv:me_all")
    b.button(text="‚úâÔ∏è ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿß ŸÖÿßŸÑ⁄©", callback_data="pv:contact_owner")
    b.button(text="üì£ Ÿæ€åÿßŸÖ ÿ®Ÿá ⁄Øÿßÿ±ÿØ", callback_data="pv:contact_guard")
    b.button(text="üö® ⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ÿßÿ±ÿ®ÿ±", callback_data="pv:report_user")
    if role in {"admin_chat","senior_chat","senior_all"} or is_owner:
        b.button(text="üßë‚Äçüíª ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Üÿ™", callback_data="pv:list_admins_chat")
        b.button(text="üìù Ÿæ€åÿßŸÖ ÿ®Ÿá ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å", callback_data="pv:send_to_main")
        b.button(text="üìÆ ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ®Ÿá ŸÖÿßŸÑ⁄© (⁄Üÿ™)", callback_data="pv:send_report_owner")
        b.button(text="üö® ⁄Øÿ≤ÿßÿ±ÿ¥ ÿßÿØŸÖ€åŸÜ ⁄Üÿ™", callback_data="pv:report_admin_chat")
    if role in {"admin_call","senior_call","senior_all"} or is_owner:
        b.button(text="üéôÔ∏è ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄©ÿßŸÑ", callback_data="pv:list_admins_voice")
        b.button(text="üìù Ÿæ€åÿßŸÖ ÿ®Ÿá ⁄Øÿ±ŸàŸá (⁄©ÿßŸÑ)", callback_data="pv:send_to_main_voice")
        b.button(text="üìÆ ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ®Ÿá ŸÖÿßŸÑ⁄© (⁄©ÿßŸÑ)", callback_data="pv:send_report_owner_voice")
        b.button(text="üö® ⁄Øÿ≤ÿßÿ±ÿ¥ ÿßÿØŸÖ€åŸÜ ⁄©ÿßŸÑ", callback_data="pv:report_admin_voice")
    b.adjust(2)
    return b.as_markup()

# ----------------------------- Guides ----------------------------------------
def help_text_for_role(role: str, is_owner: bool=False) -> str:
    base = [
        "<b>ÿ±ÿßŸáŸÜŸÖÿß€å ÿ≥ÿ±€åÿπ</b>",
        "‚Ä¢ ÿØ⁄©ŸÖŸáŸî ¬´ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ ⁄Üÿ™/⁄©ÿßŸÑ¬ª ÿ®ÿß ÿßŸàŸÑ€åŸÜ Ÿæ€åÿßŸÖ ÿßŸÖÿ±Ÿàÿ≤ ÿØÿ± ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å.",
        "‚Ä¢ ¬´ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ¬ª Ÿà ¬´ÿ´ÿ®ÿ™ ÿÆÿ±Ÿàÿ¨¬ª €å⁄©ÿ≥ÿßŸÜÿõ ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸàÿπ ÿ®ÿß ÿØ⁄©ŸÖŸá.",
        "‚Ä¢ ¬´ÿ´ÿ®ÿ™¬ª Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπŸÑ€å + ÿ¢ŸÖÿßÿ± ÿßŸÖÿ±Ÿàÿ≤ ÿ±ÿß ŸÖ€å‚ÄåÿØŸáÿØ.",
        "‚Ä¢ <b>ÿ¢ŸÖÿßÿ± ŸÅŸÇÿ∑ ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å ÿßÿ≥ÿ™.</b>",
        "‚Ä¢ ÿß⁄Øÿ± ÿØ⁄©ŸÖŸá‚ÄåŸáÿß ŸÜŸÖ€å‚Äåÿ¢€åŸÜÿØ: Ÿæÿ±ÿß€åŸàÿ≥€å BotFather ÿ±ÿß Disable ⁄©ŸÜ Ÿà ÿ¥ŸÜÿßÿ≥ŸáŸî ⁄Øÿ±ŸàŸá‚ÄåŸáÿß ÿ±ÿß ÿ®ÿß ÿØÿ≥ÿ™Ÿàÿ± ŸÖÿ™ŸÜ€å whereami ⁄Ü⁄© ⁄©ŸÜ.",
    ]
    if is_owner or role in {"senior_chat","senior_all"}:
        base += ["", "<b>ÿßÿ®ÿ≤ÿßÿ± ÿßÿ±ÿ¥ÿØ ⁄Üÿ™</b>", "ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Üÿ™ / Ÿæ€åÿßŸÖ ÿ®Ÿá ⁄Øÿ±ŸàŸá / ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ®Ÿá ŸÖÿßŸÑ⁄© / ⁄Øÿ≤ÿßÿ±ÿ¥ ÿßÿØŸÖ€åŸÜ ⁄Üÿ™"]
    if is_owner or role in {"senior_call","senior_all"}:
        base += ["", "<b>ÿßÿ®ÿ≤ÿßÿ± ÿßÿ±ÿ¥ÿØ ⁄©ÿßŸÑ</b>", "ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄©ÿßŸÑ / Ÿæ€åÿßŸÖ ÿ®Ÿá ⁄Øÿ±ŸàŸá (⁄©ÿßŸÑ) / ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ®Ÿá ŸÖÿßŸÑ⁄© (⁄©ÿßŸÑ) / ⁄Øÿ≤ÿßÿ±ÿ¥ ÿßÿØŸÖ€åŸÜ ⁄©ÿßŸÑ"]
    if is_owner or role == "owner":
        base += ["", "<i>ÿ™ÿ¥ÿÆ€åÿµ€å‚ÄåŸáÿß (ŸÖÿ™ŸÜ€å): whereami / whoami / health</i>"]
    return "\n".join(base)

def owner_help_text() -> str:
    return "\n".join([
        "<b>üëë ÿ±ÿßŸáŸÜŸÖÿß€å ⁄©ÿßŸÖŸÑ ŸÖÿßŸÑ⁄©</b>",
        "",
        "<b>ÿ™ÿ±ŸÅ€åÿπ/ÿπÿ≤ŸÑ</b>",
        "‚Ä¢ <code>ÿ™ÿ±ŸÅ€åÿπ ⁄Üÿ™ @username|id</code> ‚Äî ÿßÿØŸÖ€åŸÜ ⁄Üÿ™",
        "‚Ä¢ <code>ÿ™ÿ±ŸÅ€åÿπ ⁄©ÿßŸÑ @username|id</code> ‚Äî ÿßÿØŸÖ€åŸÜ ⁄©ÿßŸÑ",
        "‚Ä¢ <code>ÿ™ÿ±ŸÅ€åÿπ ÿßÿ±ÿ¥ÿØ⁄Üÿ™ @username|id</code> ‚Äî ÿßÿ±ÿ¥ÿØ ⁄Üÿ™",
        "‚Ä¢ <code>ÿ™ÿ±ŸÅ€åÿπ ÿßÿ±ÿ¥ÿØ⁄©ÿßŸÑ @username|id</code> ‚Äî ÿßÿ±ÿ¥ÿØ ⁄©ÿßŸÑ",
        "‚Ä¢ <code>ÿ™ÿ±ŸÅ€åÿπ ÿßÿ±ÿ¥ÿØ⁄©ŸÑ @username|id</code> ‚Äî ÿßÿ±ÿ¥ÿØ ⁄©ŸÑ",
        "‚Ä¢ <code>ÿπÿ≤ŸÑ ⁄Üÿ™|⁄©ÿßŸÑ|ÿßÿ±ÿ¥ÿØ⁄Üÿ™|ÿßÿ±ÿ¥ÿØ⁄©ÿßŸÑ|ÿßÿ±ÿ¥ÿØ⁄©ŸÑ @username|id</code>",
        "",
        "<b>ÿ¢ŸÖÿßÿ± (ŸÅŸÇÿ∑ ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å)</b>",
        "‚Ä¢ <code>ÿ¢ŸÖÿßÿ± ⁄Üÿ™ ÿßŸÑÿßŸÜ</code> ‚Äî ÿ≤ŸÖÿßŸÜ ⁄Üÿ™ + Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿßŸÖÿ±Ÿàÿ≤",
        "‚Ä¢ <code>ÿ¢ŸÖÿßÿ± ⁄©ÿßŸÑ ÿßŸÑÿßŸÜ</code> ‚Äî ÿ≤ŸÖÿßŸÜ ⁄©ÿßŸÑ ÿßŸÖÿ±Ÿàÿ≤",
        "‚Ä¢ <code>ÿ¢ŸÖÿßÿ±</code> ‚Äî ÿ™ÿπÿØÿßÿØ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÅÿπÿßŸÑ ÿßŸÖÿ±Ÿàÿ≤",
        "‚Ä¢ <code>ÿ¢ŸÖÿßÿ± ⁄©ŸÑ€å ⁄©ÿßÿ±ÿ®ÿ± id</code> ‚Äî €≥€∞ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ±",
        "",
        "<b>ÿ™⁄Ø ⁄Øÿ±ŸàŸá€å (ÿ±€åŸæŸÑÿß€å ÿ±Ÿà€å Ÿæ€åÿßŸÖ €åÿß ŸÖÿ≥ÿ™ŸÇŸÑ)</b>",
        "‚Ä¢ <code>ÿ™⁄Ø ⁄Üÿ™</code> / <code>ÿ™⁄Ø ⁄©ÿßŸÑ</code> / <code>ÿ™⁄Ø ŸáŸÖŸá</code>",
        "",
        "<b>ÿ™ÿ¥ÿÆ€åÿµ€å (ŸÖÿ™ŸÜ€å)</b>",
        "‚Ä¢ <code>whereami</code> ‚Äî Ÿáÿ±ÿ¨ÿß (ŸÅŸÇÿ∑ ŸÖÿßŸÑ⁄©/ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß)",
        "‚Ä¢ <code>whoami</code> ‚Äî Ÿæ€å‚ÄåŸà€å",
        "‚Ä¢ <code>health</code> ‚Äî Ÿæ€å‚ÄåŸà€å ŸÅŸÇÿ∑ ŸÖÿßŸÑ⁄©",
        "",
        "<b>ŸÖŸÖŸÜŸàÿπ/ÿ¢ÿ≤ÿßÿØ</b>",
        "‚Ä¢ ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ €åÿß @username €åÿß id ÿ®ÿØŸá€åÿØ: <code>ŸÖŸÖŸÜŸàÿπ</code> / <code>ÿ¢ÿ≤ÿßÿØ</code>"
    ])

# ----------------------------- Bot Init --------------------------------------
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
scheduler = AsyncIOScheduler(timezone=TEHRAN)
pool: asyncpg.Pool = None
tclient = None

# ----------------------------- Helpers (Resolvers) ---------------------------
async def resolve_user_identifier(msg: Message, ident: str | None) -> int | None:
    """
    ÿ≥ÿπ€å ŸÖ€å‚Äå⁄©ŸÜÿØ ŸáÿØŸÅ ÿ±ÿß ÿßÿ≤ €≥ ÿ±ÿßŸá Ÿæ€åÿØÿß ⁄©ŸÜÿØ:
    1) ÿ±€åŸæŸÑÿß€å ÿ®Ÿá Ÿæ€åÿßŸÖ ‚Üí from_user.id
    2) ÿ¢€åÿØ€å ÿπÿØÿØ€å
    3) @username ‚Üí ÿßŸàŸÑ Bot API (get_chat) ÿ≥Ÿæÿ≥ ÿØ€åÿ™ÿßÿ®€åÿ≥ users
    """
    # 1) reply
    if msg.reply_to_message and msg.reply_to_message.from_user:
        return msg.reply_to_message.from_user.id

    # 2) numeric id
    if ident and ident.isdigit():
        return int(ident)

    # 3) username
    if ident and ident.startswith("@"):
        uname = ident[1:]
        # try Bot API
        try:
            ch = await bot.get_chat(ident)
            if getattr(ch, "id", None):
                return ch.id
        except Exception:
            pass
        # fallback: DB (case-insensitive)
        async with pool.acquire() as con:
            uid = await con.fetchval(
                "SELECT user_id FROM users WHERE lower(username)=lower($1) LIMIT 1",
                uname
            )
            if uid:
                return int(uid)
    return None

# ----------------------------- Help Handlers ---------------------------------
@dp.message(F.text.regexp(r"^(?:ÿ±ÿßŸáŸÜŸÖÿß|help)$"), F.chat.type == ChatType.PRIVATE)
async def help_pv(msg: Message):
    role = await get_role(pool, msg.from_user.id)
    is_owner = (msg.from_user.id == OWNER_ID)
    if is_owner:
        return await msg.answer(owner_help_text())
    await msg.answer(help_text_for_role(role, is_owner))

@dp.message(F.text.regexp(r"^(?:ÿ±ÿßŸáŸÜŸÖÿß|help)$"))
async def help_anywhere(msg: Message):
    if msg.from_user.id == OWNER_ID:
        return await msg.reply(owner_help_text())
    role = await get_role(pool, msg.from_user.id)
    await msg.reply(help_text_for_role(role, is_owner=False))

# ---------------------------- Diagnostics (TEXT) ------------------------------
@dp.message(F.text.regexp(r"^(?:whereami|⁄©ÿ¨ÿß(?:€å)?(?: Ÿáÿ≥ÿ™ŸÖ)?|⁄©ÿ¨ÿß Ÿáÿ≥ÿ™€åŸÖ)$"))
async def whereami_text(msg: Message):
    who = msg.from_user
    role = await get_role(pool, who.id)
    if who.id != OWNER_ID and not is_admin_role(role):
        return await msg.reply("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ÿ®ÿ±ÿß€å ŸÖÿßŸÑ⁄©/ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿßÿ≥ÿ™.")
    title = msg.chat.title or ""
    await msg.reply(
        f"üõ∞Ô∏è <b>whereami</b>\n"
        f"chat_id: <code>{msg.chat.id}</code>\n"
        f"type: <code>{msg.chat.type}</code>\n"
        f"title: <code>{title}</code>"
    )

@dp.message(F.chat.type == ChatType.PRIVATE, F.text.regexp(r"^(?:whoami|ÿ¢€åÿØ€å ŸÖŸÜ|ÿß€åÿØ€å ŸÖŸÜ)$"))
async def whoami_text(msg: Message):
    await msg.reply(f"üÜî ÿ¢€åÿØ€å ÿ¥ŸÖÿß: <code>{msg.from_user.id}</code>")

@dp.message(F.chat.type == ChatType.PRIVATE, F.text.regexp(r"^(?:health|ÿ≥ŸÑÿßŸÖÿ™|Ÿàÿ∂ÿπ€åÿ™)$"))
async def health_text(msg: Message):
    if msg.from_user.id != OWNER_ID:
        return await msg.reply("ŸÅŸÇÿ∑ ŸÖÿßŸÑ⁄©.")
    db_ok = False
    try:
        async with pool.acquire() as con:
            _ = await con.fetchval("SELECT 1")
            db_ok = True
    except Exception as e:
        db_err = str(e)
    lines = [
        f"üíö <b>Souls Guard ‚Äî Health</b> v{APP_VERSION}",
        f"uptime: {uptime_str()}",
        f"DB: {'OK' if db_ok else 'FAIL'}",
        f"MAIN_CHAT_ID: <code>{MAIN_CHAT_ID}</code>",
        f"GUARD_CHAT_ID: <code>{GUARD_CHAT_ID}</code>",
        f"TEHRAN now: <code>{now_teh().isoformat()}</code>",
        "Jobs: autoclose(chat/call) each minute, daily rollover 00:00 Tehran",
        "‚ö†Ô∏è ÿß⁄Øÿ± ÿØÿ± ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å Ÿæ€åÿßŸÖ ŸÖ€å‚ÄåÿØŸá€åÿØ Ÿà ÿØ⁄©ŸÖŸá‚ÄåŸáÿß ŸÜŸÖ€å‚Äåÿ¢€åŸÜÿØ: Ÿæÿ±ÿß€åŸàÿ≥€å BotFather ÿ±ÿß Disable ⁄©ŸÜ€åÿØ Ÿà ÿ±ÿ®ÿßÿ™ ÿ±ÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ®Ÿá ⁄Øÿ±ŸàŸá ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ€åÿØ.",
    ]
    if not db_ok:
        lines.append(f"DB error: <code>{db_err}</code>")
    await msg.reply("\n".join(lines))

# ---------------------------- Startup ----------------------------------------
async def on_startup():
    global pool, tclient
    pool = await asyncpg.create_pool(DATABASE_URL)
    async with pool.acquire() as con:
        for stmt in [s.strip() for s in SCHEMA_SQL.split(";") if s.strip()]:
            await con.execute(stmt + ";")
        await con.execute("""
            INSERT INTO groups (group_type, chat_id, title)
            VALUES ('main', $1, 'souls')
            ON CONFLICT (group_type) DO UPDATE SET chat_id=EXCLUDED.chat_id, title=EXCLUDED.title
        """, MAIN_CHAT_ID)
        await con.execute("""
            INSERT INTO groups (group_type, chat_id, title)
            VALUES ('guard', $1, 'souls guard')
            ON CONFLICT (group_type) DO UPDATE SET chat_id=EXCLUDED.chat_id, title=EXCLUDED.title
        """, GUARD_CHAT_ID)

    if ENABLE_TELETHON and API_ID and API_HASH and TELETHON_SESSION:
        tclient = TelegramClient(StringSession(TELETHON_SESSION), API_ID, API_HASH)
        await tclient.start()
        log.info("Telethon userbot started.")

    scheduler.add_job(job_autoclose_inactive_chat, CronTrigger.from_crontab("*/1 * * * *"))
    scheduler.add_job(job_autoclose_inactive_call_fallback, CronTrigger.from_crontab("*/1 * * * *"))
    scheduler.add_job(job_daily_rollover_main_only, CronTrigger(hour=0, minute=0))
    scheduler.start()
    log.info("Scheduler started.")
    try:
        await bot.send_message(OWNER_ID, f"‚úÖ Bot started v{APP_VERSION} ‚Äî tz={TEHRAN.key}, uptime {uptime_str()}")
    except Exception:
        pass

dp.startup.register(on_startup)

# --------------------- Jobs (auto-close & daily report) ----------------------
async def job_autoclose_inactive_chat():
    try:
        async with pool.acquire() as con:
            rows = await con.fetch("""
                SELECT s.user_id
                FROM sessions s
                JOIN users u ON u.user_id=s.user_id
                WHERE s.kind='chat' AND s.end_at IS NULL
                  AND now() - s.last_activity > INTERVAL '10 minutes'
            """)
        for r in rows:
            await close_session(pool, r["user_id"], "chat")
            try:
                mention = f"<a href=\"tg://user?id={r['user_id']}\">{r['user_id']}</a>"
                text = f"‚èπÔ∏è ÿÆÿ±Ÿàÿ¨ ÿÆŸàÿØ⁄©ÿßÿ± ⁄Üÿ™ ÿ®ÿ±ÿß€å {mention} Ÿæÿ≥ ÿßÿ≤ €±€∞ ÿØŸÇ€åŸÇŸá ÿ®€å‚ÄåŸÅÿπÿßŸÑ€å ÿ´ÿ®ÿ™ ÿ¥ÿØ."
                await bot.send_message(GUARD_CHAT_ID, text)
                await bot.send_message(OWNER_ID, text)
            except Exception:
                pass
    except Exception as e:
        log.error(f"job_autoclose_inactive_chat: {e}")

async def job_autoclose_inactive_call_fallback():
    if ENABLE_TELETHON:
        return
    now = now_teh()
    to_close = []
    for uid, last in list(CALL_HEARTBEATS.items()):
        if (now - last) > timedelta(minutes=10):
            to_close.append(uid)
    for uid in to_close:
        try:
            await close_session(pool, uid, "call")
            mention = f"<a href=\"tg://user?id={uid}\">{uid}</a>"
            txt = f"‚èπÔ∏è ÿÆÿ±Ÿàÿ¨ ÿÆŸàÿØ⁄©ÿßÿ± ⁄©ÿßŸÑ ÿ®ÿ±ÿß€å {mention} Ÿæÿ≥ ÿßÿ≤ €±€∞ ÿØŸÇ€åŸÇŸá ÿ´ÿ®ÿ™ ÿ¥ÿØ."
            await bot.send_message(GUARD_CHAT_ID, txt)
            await bot.send_message(OWNER_ID, txt)
        except Exception:
            pass
        CALL_HEARTBEATS.pop(uid, None)

async def job_daily_rollover_main_only():
    try:
        rows = await admins_overview_today_main(pool)
        if not rows:
            return
        lines = ["üìä <b>ÿ¢ŸÖÿßÿ± ÿßŸÖÿ±Ÿàÿ≤ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ‚Äî ŸÅŸÇÿ∑ ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å</b>\n(ÿßÿ≤ €∞€∞:€∞€∞ ÿ™ÿß ÿß⁄©ŸÜŸàŸÜ ÿ®Ÿá ŸàŸÇÿ™ ÿ™Ÿáÿ±ÿßŸÜ)\n"]
        rows_sorted = sorted(rows, key=lambda r: (ROLE_ORDER.get(r["role"], 999), -r["msgs"], -r["chat_secs"], -r["call_secs"]))
        for r in rows_sorted:
            name = r["first_name"] or ""
            un = f"@{r['username']}" if r["username"] else ""
            rt = role_title(r["role"])
            lines.append(
                f"{rt} ‚Äî <a href=\"tg://user?id={r['user_id']}\">{name or r['user_id']}</a> {un}\n"
                f"‚Ä¢ Ÿæ€åÿßŸÖ‚ÄåŸáÿß(ÿßÿµŸÑ€å): <b>{r['msgs']}</b> | ⁄Üÿ™(ÿßÿµŸÑ€å): <b>{pretty_td(r['chat_secs'])}</b> | ⁄©ÿßŸÑ(ÿßÿµŸÑ€å): <b>{pretty_td(r['call_secs'])}</b>"
            )
        text = "\n".join(lines)
        # ÿßÿ±ÿ≥ÿßŸÑ ÿ®Ÿá Ÿæ€å‚ÄåŸà€å ŸÖÿßŸÑ⁄© Ÿà ⁄Øÿßÿ±ÿØ
        await bot.send_message(OWNER_ID, text)
        await bot.send_message(GUARD_CHAT_ID, text)
    except Exception as e:
        log.error(f"job_daily_rollover_main_only: {e}")

# ------------------------------ Handlers -------------------------------------

@dp.my_chat_member()
async def my_member_updates(ev: ChatMemberUpdated):
    try:
        chat = ev.chat
        new = ev.new_chat_member
        old = ev.old_chat_member
        await bot.send_message(
            OWNER_ID,
            f"‚ÑπÔ∏è <b>my_chat_member</b>\n"
            f"chat_id: <code>{chat.id}</code> ({chat.type})\n"
            f"status: <code>{old.status} ‚ûú {new.status}</code>\n"
            f"is_admin: <code>{getattr(new, 'is_chat_admin', False)}</code>"
        )
    except Exception:
        pass

# ÿ¥ŸÖÿßÿ±ÿ¥ Ÿæ€åÿßŸÖ‚ÄåŸáÿß: ŸÅŸÇÿ∑ ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å (ÿ®ÿ±ÿß€å ÿ¢ŸÖÿßÿ±)
@dp.message((F.chat.id == MAIN_CHAT_ID) | (F.chat.id == GUARD_CHAT_ID), F.from_user)
async def any_group_common(msg: Message):
    u = msg.from_user
    await ensure_user(pool, u)
    async with pool.acquire() as con:
        banned = await con.fetchval("SELECT 1 FROM bans WHERE user_id=$1", u.id)
    if banned:
        try:
            await bot.delete_message(msg.chat.id, msg.message_id)
        except Exception:
            pass
        return
    if msg.chat.id == MAIN_CHAT_ID:
        await inc_chat_metrics(pool, u.id, msg)

# /start ÿØÿ± Ÿæ€å‚ÄåŸà€å
@dp.message(CommandStart(), F.chat.type == ChatType.PRIVATE)
async def start_pv(msg: Message):
    await ensure_user(pool, msg.from_user)
    role = await get_role(pool, msg.from_user.id)
    if msg.from_user.id == OWNER_ID and role != "owner":
        await set_role(pool, msg.from_user.id, "owner")
        role = "owner"
    if is_admin_role(role) or msg.from_user.id == OWNER_ID:
        await msg.answer(
            "ÿ®Ÿá ŸæŸÜŸÑ ⁄Øÿßÿ±ÿØ ÿ≥ŸàŸÑÿ≤ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ.\nÿßÿ≤ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:",
            reply_markup=kb_admin_panel(role, is_owner=(msg.from_user.id==OWNER_ID))
        )
    else:
        await msg.answer(
            "ÿß€åŸÜ ÿ±ÿ®ÿßÿ™ ŸÖÿÆÿµŸàÿµ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Øÿßÿ±ÿØ ÿ≥ŸàŸÑÿ≤ ÿßÿ≥ÿ™.\n"
            "ÿ®ÿ±ÿß€å ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿß ŸÖÿßŸÑ⁄© ÿßÿ≤ ÿ±ÿ®ÿßÿ™ @soulsownerbot ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.",
            reply_markup=ReplyKeyboardRemove()
        )

# ŸÖÿπÿßÿØŸÑ ŸÖÿ™ŸÜ€å ÿ¥ÿ±Ÿàÿπ ŸæŸÜŸÑ ÿØÿ± Ÿæ€å‚ÄåŸà€å
@dp.message(F.chat.type == ChatType.PRIVATE, F.text.regexp(r"^(?:ÿ≥ŸÑÿßŸÖ|ÿ¥ÿ±Ÿàÿπ|ŸæŸÜŸÑ|panel|menu|ŸÖŸÜŸà)$"))
async def pv_open_panel(msg: Message):
    await ensure_user(pool, msg.from_user)
    role = await get_role(pool, msg.from_user.id)
    await msg.answer("ŸæŸÜŸÑ ÿ¥ŸÖÿß:", reply_markup=kb_admin_panel(role, is_owner=(msg.from_user.id==OWNER_ID)))

# ⁄Øÿ±ŸàŸá ÿßÿµŸÑ€å: ÿßŸàŸÑ€åŸÜ Ÿæ€åÿßŸÖ ÿßŸÖÿ±Ÿàÿ≤ ‚Üí ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å Ÿàÿ±ŸàÿØ ⁄Üÿ™/⁄©ÿßŸÑ
@dp.message(F.chat.id == MAIN_CHAT_ID, F.from_user)
async def main_group_prompt_first(msg: Message):
    u = msg.from_user
    await ensure_user(pool, u)
    role = await get_role(pool, u.id)
    if role in (ALLOWED_CHAT_ROLES | ALLOWED_VOICE_ROLES) or u.id == OWNER_ID:
        if await count_open(pool, u.id, "chat") == 0:
            d = today_teh()
            async with pool.acquire() as con:
                shown = await con.fetchval(
                    "SELECT 1 FROM first_prompt_main WHERE user_id=$1 AND d=$2",
                    u.id, d
                )
                if not shown:
                    await msg.reply(
                        f"ÿßŸàŸÑ€åŸÜ Ÿæ€åÿßŸÖ ÿßŸÖÿ±Ÿàÿ≤ ÿ´ÿ®ÿ™ ÿ¥ÿØ. {u.first_name} ÿπÿ≤€åÿ≤ÿå €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ±ÿß ÿ®ÿ≤ŸÜ:",
                        reply_markup=kb_first_msg_dual_checkin(u.id)
                    )
                    await con.execute(
                        "INSERT INTO first_prompt_main(user_id, d) VALUES($1,$2) ON CONFLICT DO NOTHING",
                        u.id, d
                    )

# ŸÖ€åÿßŸÜ‚Äåÿ®ÿ±Ÿáÿß€å €å⁄©ÿ≥ÿßŸÜ ¬´ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ / ÿ´ÿ®ÿ™ ÿÆÿ±Ÿàÿ¨ / ÿ´ÿ®ÿ™¬ª ÿØÿ± Ÿáÿ± ÿØŸà ⁄Øÿ±ŸàŸá (ŸÖÿ™ŸÜ€å)
@dp.message((F.chat.id == MAIN_CHAT_ID) | (F.chat.id == GUARD_CHAT_ID), F.text)
async def unified_shortcuts(msg: Message):
    u = msg.from_user
    role = await get_role(pool, u.id)
    text = re.sub(r"\s+", " ", (msg.text or "").strip().lower())
    if text not in {"ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ", "ÿ´ÿ®ÿ™ ÿÆÿ±Ÿàÿ¨", "ÿ´ÿ®ÿ™"}:
        return
    if not (role in (ALLOWED_CHAT_ROLES | ALLOWED_VOICE_ROLES) or u.id == OWNER_ID):
        return await msg.reply("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÖÿÆÿµŸàÿµ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß Ÿà ÿßÿ±ÿ¥ÿØŸáÿßÿ≥ÿ™.")

    if text == "ÿ´ÿ®ÿ™":
        st = await admin_today_stats_main(pool, u.id)
        open_chat = await count_open(pool, u.id, "chat") > 0
        open_call = await count_open(pool, u.id, "call") > 0
        status = []
        status.append(f"⁄Üÿ™: {'‚úÖ ÿ®ÿßÿ≤' if open_chat else '‚èπÔ∏è ÿ®ÿ≥ÿ™Ÿá'}")
        status.append(f"⁄©ÿßŸÑ: {'‚úÖ ÿ®ÿßÿ≤' if open_call else '‚èπÔ∏è ÿ®ÿ≥ÿ™Ÿá'}")
        txt = (f"üìç <b>Ÿàÿ∂ÿπ€åÿ™ ÿ´ÿ®ÿ™ (ÿßÿµŸÑ€å)</b>\n" +
               " ‚Äî ".join(status) + "\n\n" +
               f"üìä <b>ÿ¢ŸÖÿßÿ± ÿßŸÖÿ±Ÿàÿ≤ (ŸÅŸÇÿ∑ ÿßÿµŸÑ€å)</b>\n"
               f"Ÿæ€åÿßŸÖ‚ÄåŸáÿß: <b>{st['msgs']}</b>\n"
               f"ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß (ÿßÿ±ÿ≥ÿßŸÑ/ÿØÿ±€åÿßŸÅÿ™): <b>{st['r_sent']}/{st['r_recv']}</b>\n"
               f"ÿ≤ŸÖÿßŸÜ ⁄Üÿ™: <b>{pretty_td(st['chat_secs'])}</b>\n"
               f"ÿ≤ŸÖÿßŸÜ ⁄©ÿßŸÑ: <b>{pretty_td(st['call_secs'])}</b>")
        return await msg.reply(txt, reply_markup=kb_dual("ci", u.id, True, True))

    if text == "ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ":
        return await msg.reply("ŸÜŸàÿπ ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=kb_dual("ci", u.id, True, True))

    if text == "ÿ´ÿ®ÿ™ ÿÆÿ±Ÿàÿ¨":
        open_chat = await count_open(pool, u.id, "chat") > 0
        open_call = await count_open(pool, u.id, "call") > 0
        if open_chat ^ open_call:
            kind = "chat" if open_chat else "call"
            await close_session(pool, u.id, kind)
            if kind == "call":
                CALL_HEARTBEATS.pop(u.id, None)
            await msg.reply(f"‚èπÔ∏è ÿÆÿ±Ÿàÿ¨ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ´ÿ®ÿ™ ÿ¥ÿØ.")
            mention = f"<a href=\"tg://user?id={u.id}\">{u.first_name}</a>"
            await bot.send_message(GUARD_CHAT_ID, f"‚èπÔ∏è {mention} ÿÆÿ±Ÿàÿ¨ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ≤ÿØ.")
            await bot.send_message(OWNER_ID, f"‚èπÔ∏è {mention} ÿÆÿ±Ÿàÿ¨ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ≤ÿØ.")
        else:
            if not open_chat and not open_call:
                await msg.reply("ÿ≥ÿ¥ŸÜ€å ÿ®ÿßÿ≤ ŸÜ€åÿ≥ÿ™. ÿß⁄Øÿ± ŸÑÿßÿ≤ŸÖ ÿßÿ≥ÿ™ €å⁄©€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=kb_dual("co", u.id, True, True))
            else:
                await msg.reply("⁄©ÿØÿßŸÖ ÿ±ÿß ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿÆÿßÿ±ÿ¨ ÿ¥Ÿà€åÿØÿü", reply_markup=kb_dual("co", u.id, True, True))

# ⁄©ÿßŸÑ: ÿØ⁄©ŸÖŸáŸî ÿß€åŸÜŸÑÿß€åŸÜ ÿ®ÿß ŸÖÿ™ŸÜ ¬´⁄©ÿßŸÑ¬ª
@dp.message(F.chat.id == MAIN_CHAT_ID, F.text.regexp(r"^⁄©ÿßŸÑ$"))
async def main_group_call_help(msg: Message):
    role = await get_role(pool, msg.from_user.id)
    if (role not in (ALLOWED_CHAT_ROLES | ALLOWED_VOICE_ROLES)) and msg.from_user.id != OWNER_ID:
        return await msg.reply("ÿß€åŸÜ ÿ®ÿÆÿ¥ ŸÖÿÆÿµŸàÿµ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß/ÿßÿ±ÿ¥ÿØŸáÿß/ŸÖÿßŸÑ⁄© ÿßÿ≥ÿ™.")
    await msg.reply("ÿ®ÿ±ÿß€å ⁄©ÿßŸÑ €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ±ÿß ÿ®ÿ≤ŸÜ:", reply_markup=kb_dual("ci", msg.from_user.id, False, True))

# ⁄©ÿßŸÑ‚Äåÿ®⁄©‚ÄåŸáÿß€å Ÿàÿ±ŸàÿØ/ÿÆÿ±Ÿàÿ¨ (⁄Üÿ™/⁄©ÿßŸÑ)
@dp.callback_query(F.data.regexp(r"^(ci|co):(chat|call):(\d+)$"))
async def cb_checkin_out(cb: CallbackQuery):
    action, kind, uid = cb.data.split(":")
    uid = int(uid)
    if cb.from_user.id != uid and cb.from_user.id != OWNER_ID:
        return await cb.answer("ÿß€åŸÜ ÿØ⁄©ŸÖŸá ŸÖÿÆÿµŸàÿµ ŸáŸÖÿßŸÜ ⁄©ÿßÿ±ÿ®ÿ±/ŸÖÿßŸÑ⁄© ÿßÿ≥ÿ™.", show_alert=True)

    await ensure_user(pool, cb.from_user)
    role = await get_role(pool, cb.from_user.id)
    if kind == "chat":
        if not (role in ALLOWED_CHAT_ROLES or cb.from_user.id == OWNER_ID):
            return await cb.answer("ÿßÿ¨ÿßÿ≤ŸáŸî ⁄Üÿ™ ŸÜÿØÿßÿ±€åÿØ.", show_alert=True)
    else:
        if not (role in ALLOWED_VOICE_ROLES or cb.from_user.id == OWNER_ID):
            return await cb.answer("ÿßÿ¨ÿßÿ≤ŸáŸî ⁄©ÿßŸÑ ŸÜÿØÿßÿ±€åÿØ.", show_alert=True)

    src = f"inline:{src_tag(cb.message.chat.id)}"

    if action == "ci":
        if await count_open(pool, uid, kind) > 0:
            return await cb.answer("ÿ≥ÿ¥ŸÜ ÿ®ÿßÿ≤ ÿØÿßÿ±€å.", show_alert=True)
        await open_session(pool, uid, kind, source=src)
        if kind == "call":
            CALL_HEARTBEATS[uid] = now_teh()
        await cb.message.edit_text(f"‚úÖ ÿ´ÿ®ÿ™ Ÿàÿ±ŸàÿØ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ.")
        mention = f"<a href=\"tg://user?id={uid}\">{cb.from_user.first_name}</a>"
        await bot.send_message(GUARD_CHAT_ID, f"‚úÖ {mention} Ÿàÿ±ŸàÿØ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ≤ÿØ.")
        await bot.send_message(OWNER_ID, f"‚úÖ {mention} Ÿàÿ±ŸàÿØ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ≤ÿØ.")
    else:
        await close_session(pool, uid, kind)
        if kind == "call":
            CALL_HEARTBEATS.pop(uid, None)
        await cb.message.edit_text(f"‚èπÔ∏è ÿÆÿ±Ÿàÿ¨ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ´ÿ®ÿ™ ÿ¥ÿØ.")
        mention = f"<a href=\"tg://user?id={uid}\">{cb.from_user.first_name}</a>"
        await bot.send_message(GUARD_CHAT_ID, f"‚èπÔ∏è {mention} ÿÆÿ±Ÿàÿ¨ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ≤ÿØ.")
        await bot.send_message(OWNER_ID, f"‚èπÔ∏è {mention} ÿÆÿ±Ÿàÿ¨ {('⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ')} ÿ≤ÿØ.")
    await cb.answer()

# ----------------- ŸæŸÜŸÑ Ÿæ€åŸà€å Ÿà ÿßÿ®ÿ≤ÿßÿ±Ÿáÿß -----------------
@dp.callback_query(F.data.startswith("pv:"))
async def pv_buttons(cb: CallbackQuery):
    await ensure_user(pool, cb.from_user)
    role = await get_role(pool, cb.from_user.id)
    is_owner = (cb.from_user.id == OWNER_ID)

    if cb.data == "pv:me":
        st = await admin_today_stats_main(pool, cb.from_user.id)
        if st:
            open_chat = await count_open(pool, cb.from_user.id, "chat") > 0
            open_call = await count_open(pool, cb.from_user.id, "call") > 0
            status = f"Ÿàÿ∂ÿπ€åÿ™: ⁄Üÿ™ {'‚úÖ' if open_chat else '‚èπÔ∏è'} | ⁄©ÿßŸÑ {'‚úÖ' if open_call else '‚èπÔ∏è'}\n"
            txt = (f"üìä <b>ÿ¢ŸÖÿßÿ± ÿßŸÖÿ±Ÿàÿ≤ (ŸÅŸÇÿ∑ ÿßÿµŸÑ€å)</b>\n{status}"
                   f"Ÿæ€åÿßŸÖ‚ÄåŸáÿß: <b>{st['msgs']}</b>\n"
                   f"ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß (ÿßÿ±ÿ≥ÿßŸÑ/ÿØÿ±€åÿßŸÅÿ™): <b>{st['r_sent']}/{st['r_recv']}</b>\n"
                   f"ÿ≤ŸÖÿßŸÜ ⁄Üÿ™: <b>{pretty_td(st['chat_secs'])}</b>\n"
                   f"ÿ≤ŸÖÿßŸÜ ⁄©ÿßŸÑ: <b>{pretty_td(st['call_secs'])}</b>\n")
            await cb.message.edit_text(txt, reply_markup=kb_admin_panel(role, is_owner))
        return await cb.answer()

    if cb.data == "pv:me_all":
        st = await last_30_days_stats_main(pool, cb.from_user.id)
        txt = (f"üìà <b>€≥€∞ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ± (ŸÅŸÇÿ∑ ÿßÿµŸÑ€å)</b>\n"
               f"Ÿæ€åÿßŸÖ‚ÄåŸáÿß: <b>{st['msgs']}</b>\n"
               f"ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß (ÿßÿ±ÿ≥ÿßŸÑ/ÿØÿ±€åÿßŸÅÿ™): <b>{st['rs']}/{st['rr']}</b>\n"
               f"⁄Üÿ™: <b>{pretty_td(st['chat_secs'])}</b> | ⁄©ÿßŸÑ: <b>{pretty_td(st['call_secs'])}</b>")
        await cb.message.edit_text(txt, reply_markup=kb_admin_panel(role, is_owner))
        return await cb.answer()

    if cb.data == "pv:contact_owner":
        PENDING_CONTACT_OWNER.add(cb.from_user.id)
        await cb.message.edit_text("Ÿæ€åÿßŸÖ‚Äåÿ™ÿßŸÜ ÿ®Ÿá ŸÖÿßŸÑ⁄© ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ (ŸÑÿ∫Ÿà: ŸÑÿ∫Ÿà / cancel)")
        return await cb.answer()

    if cb.data == "pv:contact_guard":
        PENDING_CONTACT_GUARD.add(cb.from_user.id)
        await cb.message.edit_text("Ÿæ€åÿßŸÖ ÿ¥ŸÖÿß ÿ®Ÿá ⁄Øÿ±ŸàŸá ⁄Øÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ŸÖ€å‚Äåÿ¥ŸàÿØ: ÿßŸÑÿßŸÜ ŸÖÿ™ŸÜ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ. (ŸÑÿ∫Ÿà: ŸÑÿ∫Ÿà / cancel)")
        return await cb.answer()

    if cb.data == "pv:report_user":
        PENDING_REPORT[cb.from_user.id] = {"type": "member"}
        await cb.message.edit_text("ÿ¢€åÿØ€å ÿπÿØÿØ€å €åÿß €åŸàÿ≤ÿ±ŸÜ€åŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ.")
        return await cb.answer()

    if cb.data == "pv:list_admins_chat":
        if not (role in {"admin_chat","senior_chat","senior_all"} or is_owner):
            return await cb.answer("ÿßÿ¨ÿßÿ≤Ÿá ÿØÿ≥ÿ™ÿ±ÿ≥€å ŸÜÿØÿßÿ±€åÿØ.", show_alert=True)
        async with pool.acquire() as con:
            rows = await con.fetch("SELECT user_id, username, first_name, role FROM users WHERE role IN ('admin_chat','senior_chat','senior_all','owner') ORDER BY role")
        lines = ["üßë‚Äçüíª ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄Üÿ™:"]
        for r in rows:
            lines.append(f"‚Ä¢ {role_title(r['role'])}: <a href=\"tg://user?id={r['user_id']}\">{r['first_name'] or r['user_id']}</a> @{r['username'] or ''}")
        await cb.message.edit_text("\n".join(lines))
        return await cb.answer()

    if cb.data == "pv:list_admins_voice":
        if not (role in {"admin_call","senior_call","senior_all"} or is_owner):
            return await cb.answer("ÿßÿ¨ÿßÿ≤Ÿá ÿØÿ≥ÿ™ÿ±ÿ≥€å ŸÜÿØÿßÿ±€åÿØ.", show_alert=True)
        async with pool.acquire() as con:
            rows = await con.fetch("SELECT user_id, username, first_name, role FROM users WHERE role IN ('admin_call','senior_call','senior_all','owner') ORDER BY role")
        lines = ["üéôÔ∏è ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß€å ⁄©ÿßŸÑ:"]
        for r in rows:
            lines.append(f"‚Ä¢ {role_title(r['role'])}: <a href=\"tg://user?id={r['user_id']}\">{r['first_name'] or r['user_id']}</a> @{r['username'] or ''}")
        await cb.message.edit_text("\n".join(lines))
        return await cb.answer()

    if cb.data in {"pv:send_to_main","pv:send_report_owner","pv:report_admin_chat"}:
        if not (role in {"admin_chat","senior_chat","senior_all"} or is_owner):
            return await cb.answer("ÿßÿ¨ÿßÿ≤Ÿá ÿØÿ≥ÿ™ÿ±ÿ≥€å ŸÜÿØÿßÿ±€åÿØ.", show_alert=True)
        await cb.message.edit_text("ŸÖÿ™ŸÜ ÿÆŸàÿØ ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ. (ŸÑÿ∫Ÿà: ŸÑÿ∫Ÿà / cancel)")
        PENDING_REPORT[cb.from_user.id] = {"type": cb.data}
        return await cb.answer()

    if cb.data in {"pv:send_to_main_voice","pv:send_report_owner_voice","pv:report_admin_voice"}:
        if not (role in {"admin_call","senior_call","senior_all"} or is_owner):
            return await cb.answer("ÿßÿ¨ÿßÿ≤Ÿá ÿØÿ≥ÿ™ÿ±ÿ≥€å ŸÜÿØÿßÿ±€åÿØ.", show_alert=True)
        await cb.message.edit_text("ŸÖÿ™ŸÜ ÿÆŸàÿØ ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ. (ŸÑÿ∫Ÿà: ŸÑÿ∫Ÿà / cancel)")
        PENDING_REPORT[cb.from_user.id] = {"type": cb.data}
        return await cb.answer()

    return await cb.answer()

# ÿØÿ±€åÿßŸÅÿ™ ŸÖÿ™ŸÜ‚ÄåŸáÿß€å Ÿæÿ≥ ÿßÿ≤ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å Ÿæ€åŸà€å + fallbackŸáÿß€å ŸÖÿ™ŸÜ€å
@dp.message(F.chat.type == ChatType.PRIVATE)
async def pv_text_flow(msg: Message):
    uid = msg.from_user.id
    role = await get_role(pool, uid)

    if (msg.text or "").strip().lower() in {"ŸÑÿ∫Ÿà", "cancel", "/cancel"}:
        PENDING_CONTACT_GUARD.discard(uid)
        PENDING_CONTACT_OWNER.discard(uid)
        PENDING_REPORT.pop(uid, None)
        return await msg.reply("ŸÑÿ∫Ÿà ÿ¥ÿØ.", reply_markup=kb_admin_panel(role, is_owner=(uid==OWNER_ID)))

    t = (msg.text or "").strip().lower()

    if t in {"ŸæŸÜŸÑ","panel","menu","ŸÖŸÜŸà"}:
        return await msg.answer("ŸæŸÜŸÑ ÿ¥ŸÖÿß:", reply_markup=kb_admin_panel(role, is_owner=(uid==OWNER_ID)))

    if t in {"ÿ¢ŸÖÿßÿ± ŸÖŸÜ","stats me"}:
        st = await admin_today_stats_main(pool, uid)
        open_chat = await count_open(pool, uid, "chat") > 0
        open_call = await count_open(pool, uid, "call") > 0
        status = f"Ÿàÿ∂ÿπ€åÿ™: ⁄Üÿ™ {'‚úÖ' if open_chat else '‚èπÔ∏è'} | ⁄©ÿßŸÑ {'‚úÖ' if open_call else '‚èπÔ∏è'}\n"
        txt = (f"üìä <b>ÿ¢ŸÖÿßÿ± ÿßŸÖÿ±Ÿàÿ≤ (ŸÅŸÇÿ∑ ÿßÿµŸÑ€å)</b>\n{status}"
               f"Ÿæ€åÿßŸÖ‚ÄåŸáÿß: <b>{st['msgs']}</b>\n"
               f"ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß (ÿßÿ±ÿ≥ÿßŸÑ/ÿØÿ±€åÿßŸÅÿ™): <b>{st['r_sent']}/{st['r_recv']}</b>\n"
               f"ÿ≤ŸÖÿßŸÜ ⁄Üÿ™: <b>{pretty_td(st['chat_secs'])}</b>\n"
               f"ÿ≤ŸÖÿßŸÜ ⁄©ÿßŸÑ: <b>{pretty_td(st['call_secs'])}</b>\n")
        return await msg.answer(txt, reply_markup=kb_dual("ci", uid, True, True))

    if t in {"ÿ¢ŸÖÿßÿ± ⁄©ŸÑ€å ŸÖŸÜ","stats all"}:
        st = await last_30_days_stats_main(pool, uid)
        txt = (f"üìà <b>€≥€∞ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ± (ŸÅŸÇÿ∑ ÿßÿµŸÑ€å)</b>\n"
               f"Ÿæ€åÿßŸÖ‚ÄåŸáÿß: <b>{st['msgs']}</b>\n"
               f"ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß (ÿßÿ±ÿ≥ÿßŸÑ/ÿØÿ±€åÿßŸÅÿ™): <b>{st['rs']}/{st['rr']}</b>\n"
               f"⁄Üÿ™: <b>{pretty_td(st['chat_secs'])}</b> | ⁄©ÿßŸÑ: <b>{pretty_td(st['call_secs'])}</b>")
        return await msg.answer(txt)

    if t in {"ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿß ŸÖÿßŸÑ⁄©","contact owner"}:
        PENDING_CONTACT_OWNER.add(uid)
        return await msg.answer("Ÿæ€åÿßŸÖ‚Äåÿ™ÿßŸÜ ÿ®Ÿá ŸÖÿßŸÑ⁄© ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ (ŸÑÿ∫Ÿà: ŸÑÿ∫Ÿà / cancel)")

    if t in {"Ÿæ€åÿßŸÖ ÿ®Ÿá ⁄Øÿßÿ±ÿØ","contact guard"}:
        PENDING_CONTACT_GUARD.add(uid)
        return await msg.answer("Ÿæ€åÿßŸÖ ÿ¥ŸÖÿß ÿ®Ÿá ⁄Øÿ±ŸàŸá ⁄Øÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ŸÖ€å‚Äåÿ¥ŸàÿØ: ÿßŸÑÿßŸÜ ŸÖÿ™ŸÜ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ. (ŸÑÿ∫Ÿà: ŸÑÿ∫Ÿà / cancel)")

    if t in {"⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ÿßÿ±ÿ®ÿ±","report user"}:
        PENDING_REPORT[uid] = {"type": "member"}
        return await msg.answer("ÿ¢€åÿØ€å ÿπÿØÿØ€å €åÿß €åŸàÿ≤ÿ±ŸÜ€åŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ.")

    if uid in PENDING_CONTACT_OWNER:
        PENDING_CONTACT_OWNER.discard(uid)
        await bot.send_message(OWNER_ID, f"üì© Ÿæ€åÿßŸÖ ÿßÿ≤ <a href=\"tg://user?id={uid}\">{msg.from_user.first_name}</a>:\n{msg.text}")
        return await msg.reply("ÿ®Ÿá ŸÖÿßŸÑ⁄© ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ ‚úÖ")

    if uid in PENDING_CONTACT_GUARD:
        PENDING_CONTACT_GUARD.discard(uid)
        await bot.send_message(GUARD_CHAT_ID, f"üì£ Ÿæ€åÿßŸÖ ÿßÿ≤ <a href=\"tg://user?id={uid}\">{msg.from_user.first_name}</a>:\n{msg.text}")
        return await msg.reply("ÿ®Ÿá ⁄Øÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ ‚úÖ")

    if uid in PENDING_REPORT:
        ctx = PENDING_REPORT.pop(uid)
        if ctx["type"] == "member":
            await bot.send_message(OWNER_ID, f"üö® ⁄Øÿ≤ÿßÿ±ÿ¥ ÿßÿ≤ <a href=\"tg://user?id={uid}\">{msg.from_user.first_name}</a>:\n{msg.text}")
            return await msg.reply("⁄Øÿ≤ÿßÿ±ÿ¥ ÿ®Ÿá ŸÖÿßŸÑ⁄© ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ ‚úÖ")

# ------------------ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ€å ÿ®ÿ±ÿß€å ÿßÿπÿ∂ÿß€å ÿπÿßÿØ€å ------------------
def kb_apply_admin():
    b = InlineKeyboardBuilder()
    b.button(text="üì® ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ€å ⁄Üÿ™", callback_data="rq:chat")
    b.button(text="üéôÔ∏è ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ€å ⁄©ÿßŸÑ", callback_data="rq:call")
    b.adjust(1,1)
    return b.as_markup()

@dp.message((F.chat.id == MAIN_CHAT_ID) | (F.chat.id == GUARD_CHAT_ID), F.text.regexp(r"^ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ€å$"))
async def request_admin_command(msg: Message):
    role = await get_role(pool, msg.from_user.id)
    if role != "member":
        return await msg.reply("ÿ¥ŸÖÿß ŸáŸÖ‚Äåÿß⁄©ŸÜŸàŸÜ ÿπÿ∂Ÿà ⁄Øÿßÿ±ÿØ Ÿáÿ≥ÿ™€åÿØ. ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜ€åÿßÿ≤ ÿ®ÿß ÿßÿ±ÿ¥ÿØŸáÿß/ŸÖÿßŸÑ⁄© ŸáŸÖÿßŸáŸÜ⁄Ø ⁄©ŸÜ€åÿØ.")
    await msg.reply("ŸÜŸàÿπ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=kb_apply_admin())

async def get_user_last_days_stats(pool, user_id: int, days: int = 7):
    start_d = today_teh() - timedelta(days=days)
    pat = _main_src_like()
    async with pool.acquire() as con:
        row = await con.fetchrow("""
        WITH cm AS (
            SELECT COALESCE(SUM(msgs),0) AS chat_msgs
            FROM chat_metrics
            WHERE user_id=$1 AND d >= $2
        ),
        chat_secs AS (
            SELECT COALESCE(SUM(EXTRACT(EPOCH FROM (COALESCE(end_at,now()) - start_at)))::INT,0) AS secs
            FROM sessions WHERE user_id=$1 AND kind='chat' AND start_date >= $2 AND source LIKE $3
        ),
        call_secs AS (
            SELECT COALESCE(SUM(EXTRACT(EPOCH FROM (COALESCE(end_at,now()) - start_at)))::INT,0) AS secs
            FROM sessions WHERE user_id=$1 AND kind='call' AND start_date >= $2 AND source LIKE $3
        )
        SELECT cm.chat_msgs, chat_secs.secs AS chat_secs, call_secs.secs AS call_secs
        FROM cm, chat_secs, call_secs
        """, user_id, start_d, pat)
    return row or {"chat_msgs":0, "chat_secs":0, "call_secs":0}

@dp.callback_query(F.data.regexp(r"^rq:(chat|call)$"))
async def request_admin_cb(cb: CallbackQuery):
    kind = cb.data.split(":")[1]
    uid = cb.from_user.id
    role = await get_role(pool, uid)
    if role != "member":
        await cb.answer("ÿ¥ŸÖÿß ŸáŸÖ‚Äåÿß⁄©ŸÜŸàŸÜ ÿπÿ∂Ÿà ⁄Øÿßÿ±ÿØ Ÿáÿ≥ÿ™€åÿØ.", show_alert=True); return
    st7 = await get_user_last_days_stats(pool, uid, days=7)
    name = cb.from_user.first_name or str(uid)
    un = f"@{cb.from_user.username}" if cb.from_user.username else ""
    text = (
        f"üìù <b>ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ€å {'⁄Üÿ™' if kind=='chat' else '⁄©ÿßŸÑ'}</b>\n"
        f"ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåÿØŸáŸÜÿØŸá: <a href=\"tg://user?id={uid}\">{name}</a> {un}\n"
        f"‚Ä¢ Ÿæ€åÿßŸÖ‚ÄåŸáÿß (€∑ÿ±Ÿàÿ≤/ÿßÿµŸÑ€å): <b>{st7['chat_msgs']}</b>\n"
        f"‚Ä¢ ÿ≤ŸÖÿßŸÜ ⁄Üÿ™ (€∑ÿ±Ÿàÿ≤/ÿßÿµŸÑ€å): <b>{pretty_td(st7['chat_secs'])}</b>\n"
        f"‚Ä¢ ÿ≤ŸÖÿßŸÜ ⁄©ÿßŸÑ (€∑ÿ±Ÿàÿ≤/ÿßÿµŸÑ€å): <b>{pretty_td(st7['call_secs'])}</b>\n"
    )
    await bot.send_message(GUARD_CHAT_ID, text)
    await bot.send_message(OWNER_ID, text)
    await cb.message.edit_text("‚úÖ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ¥ŸÖÿß ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ. ŸÜÿ™€åÿ¨Ÿá ÿßÿ≤ ÿ∑ÿ±ŸÅ ŸÖÿØ€åÿ±€åÿ™ ÿßÿπŸÑÿßŸÖ ŸÖ€å‚Äåÿ¥ŸàÿØ.")
    await cb.answer()

# ------------------ ÿ™⁄Ø ⁄Øÿ±ŸàŸá€å (ŸáŸÖŸá‚Äåÿ¨ÿß) ------------------
async def fetch_role_user_ids(pool, roles):
    async with pool.acquire() as con:
        rows = await con.fetch("SELECT user_id, first_name FROM users WHERE role = ANY($1::text[])", list(roles))
    return [(r["user_id"], r["first_name"] or str(r["user_id"])) for r in rows]

def mentions_from_list(items, limit=50):
    out = []
    for uid, name in items[:limit]:
        out.append(f"<a href=\"tg://user?id={uid}\">{name}</a>")
    return " ".join(out)

@dp.message(F.text.regexp(r"^ÿ™⁄Ø\s*(⁄Üÿ™|⁄©ÿßŸÑ|ŸáŸÖŸá)$"))
async def tag_commands(msg: Message):
    who = msg.from_user
    role = await get_role(pool, who.id)
    target = (msg.text or "").strip().split()[-1]

    if who.id != OWNER_ID and role not in {"senior_all","senior_chat","senior_call"}:
        return await msg.reply("ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ŸÖÿßŸÑ⁄© Ÿà ÿßÿ±ÿ¥ÿØŸáÿßÿ≥ÿ™.")
    if target == "ŸáŸÖŸá" and (who.id != OWNER_ID and role != "senior_all"):
        return await msg.reply("¬´ÿ™⁄Ø ŸáŸÖŸá¬ª ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ŸÖÿßŸÑ⁄© €åÿß ÿßÿ±ÿ¥ÿØ⁄©ŸÑ ŸÖÿ¨ÿßÿ≤ ÿßÿ≥ÿ™.")

    tag_ids = []
    if target == "⁄Üÿ™":
        ids = await fetch_role_user_ids(pool, {"admin_chat","senior_chat","senior_all","owner"})
        tag_ids.extend(ids)
    elif target == "⁄©ÿßŸÑ":
        ids = await fetch_role_user_ids(pool, {"admin_call","senior_call","senior_all","owner"})
        tag_ids.extend(ids)
    else:
        ids1 = await fetch_role_user_ids(pool, {"admin_chat","senior_chat"})
        ids2 = await fetch_role_user_ids(pool, {"admin_call","senior_call"})
        ids3 = await fetch_role_user_ids(pool, {"senior_all","owner"})
        seen = set(); merged = []
        for lst in (ids1+ids2+ids3):
            if lst[0] not in seen:
                seen.add(lst[0]); merged.append(lst)
        tag_ids = merged

    if not tag_ids:
        return await msg.reply("⁄©ÿ≥€å ÿ®ÿ±ÿß€å ÿ™⁄Ø €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
    tags = mentions_from_list(tag_ids, limit=50)
    if msg.reply_to_message:
        await msg.reply_to_message.reply(f"üîî {tags}")
    else:
        await msg.reply(f"üîî {tags}")

# ------------------ ÿ±ÿ£€å ŸÖÿßŸÑ⁄© ------------------
@dp.callback_query(F.data.regexp(r"^fb:(\d+):(-?1)$"))
async def feedback_cb(cb: CallbackQuery):
    target, score = cb.data.split(":")[1:]
    target = int(target); score = int(score)
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("ŸÅŸÇÿ∑ ŸÖÿßŸÑ⁄© ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ±ÿ£€å ÿØŸáÿØ.", show_alert=True)
    async with pool.acquire() as con:
        await con.execute("INSERT INTO feedback(target_user_id, giver_user_id, d, score) VALUES($1,$2,$3,$4)",
                          target, OWNER_ID, today_teh(), score)
    await cb.answer("ÿ´ÿ®ÿ™ ÿ¥ÿØ.", show_alert=False)
    await cb.message.edit_reply_markup(reply_markup=None)

# ----------------------- ÿØÿ≥ÿ™Ÿàÿ±Ÿáÿß€å ŸÖÿ™ŸÜ€å ŸÖÿßŸÑ⁄© (ÿ®ÿØŸàŸÜ /) -----------------------
OWNER_CMD_PATTERNS = [
    (r"^(ÿ™ÿ±ŸÅ€åÿπ|ÿπÿ≤ŸÑ)\s+(⁄Üÿ™|⁄©ÿßŸÑ|ÿßÿ±ÿ¥ÿØ⁄Üÿ™|ÿßÿ±ÿ¥ÿØ⁄©ÿßŸÑ|ÿßÿ±ÿ¥ÿØ⁄©ŸÑ)\s+(@\w+|\d+)?$", "promote_demote"),
    (r"^ÿ¢ŸÖÿßÿ±\s*⁄Üÿ™\s*ÿßŸÑÿßŸÜ$", "stats_chat_now"),
    (r"^ÿ¢ŸÖÿßÿ±\s*⁄©ÿßŸÑ\s*ÿßŸÑÿßŸÜ$", "stats_call_now"),
    (r"^ÿ¢ŸÖÿßÿ±\s*$", "stats_active"),
    (r"^ŸÖŸÖŸÜŸàÿπ(?:\s+(@\w+|\d+))?$", "ban_user"),
    (r"^ÿ¢ÿ≤ÿßÿØ(?:\s+(@\w+|\d+))?$", "unban_user"),
    (r"^ÿßÿ™⁄©\s*ÿ®⁄©\s+(.+)$", "attack_back"),
    (r"^ÿ™ÿß€åÿ™ŸÑ\s*⁄©ÿßŸÑ\s+(.+)$", "call_title"),
    (r"^ÿ¢ŸÖÿßÿ±\s*⁄©ŸÑ€å\s*⁄©ÿßÿ±ÿ®ÿ±\s+(\d+)$", "user_month")
]

ROLE_MAP = {
    "⁄Üÿ™": "admin_chat",
    "⁄©ÿßŸÑ": "admin_call",
    "ÿßÿ±ÿ¥ÿØ⁄Üÿ™": "senior_chat",
    "ÿßÿ±ÿ¥ÿØ⁄©ÿßŸÑ": "senior_call",
    "ÿßÿ±ÿ¥ÿØ⁄©ŸÑ": "senior_all"
}

@dp.message(F.from_user.id == OWNER_ID)
async def owner_text_commands(msg: Message):
    text_raw = (msg.text or "").strip()
    text = re.sub(r"\s+", " ", text_raw)
    if re.fullmatch(r"(?:ÿ±ÿßŸáŸÜŸÖÿß|help)", text):
        return await msg.reply(owner_help_text())

    for pat, name in OWNER_CMD_PATTERNS:
        m = re.match(pat, text)
        if not m: 
            continue

        # -------- ÿ™ÿ±ŸÅ€åÿπ/ÿπÿ≤ŸÑ ÿ®ÿß ÿ±€åŸæŸÑÿß€å/ID/@username --------
        if name == "promote_demote":
            act, kind, ident = m.groups()
            target_id = await resolve_user_identifier(msg, ident)
            if not target_id:
                return await msg.reply("‚ùó ŸÑÿ∑ŸÅÿßŸã ÿ±Ÿà€å Ÿæ€åÿßŸÖ ŸÅÿ±ÿØ ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ €åÿß ÿ¢€åÿØ€å ÿπÿØÿØ€å/€åŸàÿ≤ÿ±ŸÜ€åŸÖ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿØŸá€åÿØ.")
            role_key = ROLE_MAP[kind]
            if act == "ÿ™ÿ±ŸÅ€åÿπ":
                ok = await set_role(pool, target_id, role_key)
                if not ok:
                    await msg.reply("ŸÜŸÇÿ¥ ŸÜÿßŸÖÿπÿ™ÿ®ÿ±.")
                    return
                await msg.reply(f"‚úÖ {target_id} ÿ®Ÿá {role_title(role_key)} ÿ™ÿ±ŸÅ€åÿπ €åÿßŸÅÿ™.")
            else:
                await set_role(pool, target_id, "member")
                await msg.reply(f"‚úÖ {target_id} ÿπÿ≤ŸÑ ÿ¥ÿØ.")
            return

        # -------- ÿ¢ŸÖÿßÿ± ŸÑÿ≠ÿ∏Ÿá‚Äåÿß€å (ÿßÿ±ÿ≥ÿßŸÑ ÿ®Ÿá PV ŸÖÿßŸÑ⁄© Ÿà ⁄Øÿßÿ±ÿØ) --------
        elif name == "stats_chat_now":
            rows = await admins_overview_today_main(pool)
            lines = ["üìä ÿ¢ŸÖÿßÿ± ⁄Üÿ™ ÿ™ÿß ÿß€åŸÜ ŸÑÿ≠ÿ∏Ÿá ‚Äî ŸÅŸÇÿ∑ ÿßÿµŸÑ€å:"]
            for r in sorted(rows, key=lambda r: ROLE_ORDER.get(r["role"], 99)):
                lines.append(f"{role_title(r['role'])} ‚Äî <a href=\"tg://user?id={r['user_id']}\">{r['first_name'] or r['user_id']}</a>: ⁄Üÿ™ {pretty_td(r['chat_secs'])} | Ÿæ€åÿßŸÖ {r['msgs']}")
            text_stats = "\n".join(lines)
            await bot.send_message(OWNER_ID, text_stats)
            await bot.send_message(GUARD_CHAT_ID, text_stats)
            await msg.reply("‚úÖ ÿ¢ŸÖÿßÿ± ÿ®Ÿá Ÿæ€å‚ÄåŸà€å ŸÖÿßŸÑ⁄© Ÿà ⁄Øÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.")
            return

        elif name == "stats_call_now":
            rows = await admins_overview_today_main(pool)
            lines = ["üéôÔ∏è ÿ¢ŸÖÿßÿ± ⁄©ÿßŸÑ ÿ™ÿß ÿß€åŸÜ ŸÑÿ≠ÿ∏Ÿá ‚Äî ŸÅŸÇÿ∑ ÿßÿµŸÑ€å:"]
            for r in sorted(rows, key=lambda r: ROLE_ORDER.get(r["role"], 99)):
                lines.append(f"{role_title(r['role'])} ‚Äî <a href=\"tg://user?id={r['user_id']}\">{r['first_name'] or r['user_id']}</a>: ⁄©ÿßŸÑ {pretty_td(r['call_secs'])}")
            text_stats = "\n".join(lines)
            await bot.send_message(OWNER_ID, text_stats)
            await bot.send_message(GUARD_CHAT_ID, text_stats)
            await msg.reply("‚úÖ ÿ¢ŸÖÿßÿ± ÿ®Ÿá Ÿæ€å‚ÄåŸà€å ŸÖÿßŸÑ⁄© Ÿà ⁄Øÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.")
            return

        elif name == "stats_active":
            async with pool.acquire() as con:
                n = await con.fetchval("SELECT COUNT(DISTINCT user_id) FROM chat_metrics WHERE d=$1", today_teh())
            text_stats = f"üë• ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÅÿπÿßŸÑ ÿßŸÖÿ±Ÿàÿ≤ (ÿßÿµŸÑ€å): <b>{n}</b>"
            await bot.send_message(OWNER_ID, text_stats)
            await bot.send_message(GUARD_CHAT_ID, text_stats)
            await msg.reply("‚úÖ ÿ¢ŸÖÿßÿ± ÿ®Ÿá Ÿæ€å‚ÄåŸà€å ŸÖÿßŸÑ⁄© Ÿà ⁄Øÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.")
            return

        # -------- ŸÖŸÖŸÜŸàÿπ / ÿ¢ÿ≤ÿßÿØ ÿ®ÿß ÿ±€åŸæŸÑÿß€å/ID/@username --------
        elif name == "ban_user":
            ident = m.group(1)
            uid = await resolve_user_identifier(msg, ident)
            if not uid:
                return await msg.reply("‚ùó ÿ®ÿ±ÿß€å ŸÖŸÖŸÜŸàÿπ‚Äå⁄©ÿ±ÿØŸÜÿå ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ €åÿß ÿ¢€åÿØ€å/€åŸàÿ≤ÿ±ŸÜ€åŸÖ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿØŸá€åÿØ.")
            async with pool.acquire() as con:
                await con.execute("INSERT INTO bans(user_id) VALUES($1) ON CONFLICT (user_id) DO NOTHING", uid)
            txt = f"‚õî ⁄©ÿßÿ±ÿ®ÿ± {uid} ÿØÿ± ŸÑ€åÿ≥ÿ™ ŸÖŸÖŸÜŸàÿπ ŸÇÿ±ÿßÿ± ⁄Øÿ±ŸÅÿ™."
            await msg.reply(txt)
            await bot.send_message(OWNER_ID, txt)
            await bot.send_message(GUARD_CHAT_ID, txt)
            return

        elif name == "unban_user":
            ident = m.group(1)
            uid = await resolve_user_identifier(msg, ident)
            if not uid:
                return await msg.reply("‚ùó ÿ®ÿ±ÿß€å ÿ¢ÿ≤ÿßÿØ⁄©ÿ±ÿØŸÜÿå ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ€åÿØ €åÿß ÿ¢€åÿØ€å/€åŸàÿ≤ÿ±ŸÜ€åŸÖ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿØŸá€åÿØ.")
            async with pool.acquire() as con:
                await con.execute("DELETE FROM bans WHERE user_id=$1", uid)
            txt = f"‚úÖ ⁄©ÿßÿ±ÿ®ÿ± {uid} ÿ¢ÿ≤ÿßÿØ ÿ¥ÿØ."
            await msg.reply(txt)
            await bot.send_message(OWNER_ID, txt)
            await bot.send_message(GUARD_CHAT_ID, txt)
            return

        elif name == "attack_back":
            link = m.group(1).strip()
            if not ENABLE_TELETHON or not tclient:
                return await msg.reply("ÿ®ÿ±ÿß€å ÿßÿ™⁄©‚Äåÿ®⁄© ÿ®ÿß€åÿØ Telethon ŸÅÿπÿßŸÑ ÿ®ÿßÿ¥ÿØ. (ENABLE_TELETHON=1 Ÿà ÿ≥ÿ¥ŸÜ ŸÖÿπÿ™ÿ®ÿ±)")
            try:
                entity = await tclient.get_entity(link)
                await tclient.join(entity)
                from telethon.tl.functions.channels import GetParticipantsRequest
                from telethon.tl.types import ChannelParticipantsAdmins, ChannelParticipantsRecent
                admins = await tclient(GetParticipantsRequest(entity, ChannelParticipantsAdmins(), 0, 1000, 0))
                recents = await tclient(GetParticipantsRequest(entity, ChannelParticipantsRecent(), 0, 2000, 0))
                admin_ids = {p.user_id for p in admins.participants}
                target_ids = {p.user_id for p in recents.participants}
                async with pool.acquire() as con:
                    main_ids = {r["user_id"] for r in await con.fetch("SELECT DISTINCT user_id FROM chat_metrics")}
                commons = target_ids & main_ids
                lines = ["üõ°Ô∏è ⁄Øÿ≤ÿßÿ±ÿ¥ ÿßÿ™⁄© ÿßÿÆ€åÿ±:"]
                if admin_ids:
                    lines.append("‚Ä¢ ŸÖŸÇÿßŸÖ‚ÄåÿØÿßÿ±ÿßŸÜ ŸÖŸÇÿµÿØ:")
                    for uid2 in list(admin_ids)[:50]:
                        lines.append(f" - <a href=\"tg://user?id={uid2}\">{uid2}</a>")
                if commons:
                    lines.append("\n‚Ä¢ ÿßÿπÿ∂ÿß€å ŸÖÿ¥ÿ™ÿ±⁄©:")
                    for uid2 in list(commons)[:100]:
                        lines.append(f" - <a href=\"tg://user?id={uid2}\">{uid2}</a>")
                report_txt = "\n".join(lines)
                await bot.send_message(GUARD_CHAT_ID, report_txt)
                await bot.send_message(OWNER_ID, report_txt)
                await msg.reply("⁄Øÿ≤ÿßÿ±ÿ¥ ÿßÿ™⁄© ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.")
            except Exception as e:
                await msg.reply(f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ™⁄©‚Äåÿ®⁄©: {e}")
            return

        elif name == "call_title":
            title = m.group(1).strip()
            if not ENABLE_TELETHON or not tclient:
                return await msg.reply("ÿ™ŸÜÿ∏€åŸÖ ÿπŸÜŸàÿßŸÜ ⁄©ÿßŸÑ ŸÅŸÇÿ∑ ÿ®ÿß €åŸàÿ≤ÿ±ÿ®ÿßÿ™ (Telethon) ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™.")
            try:
                await msg.reply("(ŸÜŸÖŸàŸÜŸá) ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ™ÿ∫€å€åÿ± ÿπŸÜŸàÿßŸÜ ⁄©ÿßŸÑ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ. (Ÿæ€åÿßÿØŸá‚Äåÿ≥ÿßÿ≤€å ÿØŸÇ€åŸÇ ŸÖŸàÿ±ÿØŸÜ€åÿßÿ≤)")
            except Exception as e:
                await msg.reply(f"ÿÆÿ∑ÿß: {e}")
            return

        elif name == "user_month":
            uid_req = int(m.group(1))
            st = await last_30_days_stats_main(pool, uid_req)
            role_req = await get_role(pool, uid_req)
            async with pool.acquire() as con:
                jg = await con.fetchval("SELECT joined_guard_at FROM users WHERE user_id=$1", uid_req)
            txt = (f"üìö ÿ¢ŸÖÿßÿ± €≥€∞ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ± ⁄©ÿßÿ±ÿ®ÿ± {uid_req} ({role_title(role_req)}) ‚Äî ŸÅŸÇÿ∑ ÿßÿµŸÑ€å\n"
                   f"Ÿæ€åÿßŸÖ‚ÄåŸáÿß: {st['msgs']} | ÿ±€åŸæŸÑÿß€å‚ÄåŸáÿß: {st['rs']}/{st['rr']}\n"
                   f"⁄Üÿ™: {pretty_td(st['chat_secs'])} | ⁄©ÿßŸÑ: {pretty_td(st['call_secs'])}\n"
                   f"ÿ™ÿßÿ±€åÿÆ ÿßŸÑÿ≠ÿßŸÇ ÿ®Ÿá ⁄Øÿßÿ±ÿØ: {jg if jg else 'ŸÜÿßŸÖÿ¥ÿÆÿµ'}")
            await bot.send_message(OWNER_ID, txt)
            await bot.send_message(GUARD_CHAT_ID, txt)
            await msg.reply("‚úÖ ÿ¢ŸÖÿßÿ± ÿ®Ÿá Ÿæ€å‚ÄåŸà€å ŸÖÿßŸÑ⁄© Ÿà ⁄Øÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.")
            return

# ------------------------------ RUN -----------------------------------------
async def on_error(event, exception):
    log.error(f"Error: {exception}")

async def main():
    dp.errors.register(on_error)
    await dp.start_polling(bot, allowed_updates=["message","callback_query","chat_member","my_chat_member"])

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        pass
